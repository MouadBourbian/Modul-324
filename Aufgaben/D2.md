# D2: Branching Strategie und Semantic Versioning

## Branching Strategie

### Zielsetzung

Die Branching Strategie dient der strukturierten Zusammenarbeit im Team sowie der Qualitätssicherung des Codes. Sie definiert, wie neue Features, Bugfixes und Releases entwickelt, getestet und in die Hauptentwicklung integriert werden.

### Wahl der Strategie

Wir setzen eine **vereinfachte GitFlow-Strategie** ein, da diese für kleine bis mittlere Projekte geeignet ist. Sie ermöglicht uns:

- eine klare Trennung zwischen stabilen Produktions-Releases und laufender Entwicklung,
- die Integration von Code-Reviews durch Pull Requests,
- die einfache Erweiterung um Continuous Integration (CI) und Continuous Delivery (CD).

### Branch-Typen und Verwendungszweck

| Branch-Typ   | Zweck                                                                                             | Namenskonvention         |
| ------------ | ------------------------------------------------------------------------------------------------- | ------------------------ |
| **main**     | Produktionsbereit, enthält ausschließlich getestete und freigegebene Versionen.                   | `main`                   |
| **develop**  | Hauptentwicklungszweig. Hier werden Features und Bugfixes integriert.                             | `develop`                |
| **feature/** | Entwicklung neuer Features. Wird von `develop` abgezweigt und dorthin zurückgeführt.              | `feature/<feature-name>` |
| **bugfix/**  | Behebung von Fehlern, die noch nicht produktiv sind. Basis: `develop`.                            | `bugfix/<ticket-id>`     |
| **hotfix/**  | Kritische Fehlerbehebung in der Produktion. Basis: `main`, Rückführung nach `main` und `develop`. | `hotfix/<ticket-id>`     |
| **release/** | Vorbereitung auf ein Release. Enthält letzte Tests und Dokumentationsanpassungen.                 | `release/<version>`      |

### Erlaubte Merge-Wege

- `feature/*` → **merge** nach `develop` (via Pull Request, mit Code Review).
- `bugfix/*` → **merge** nach `develop` (via Pull Request).
- `hotfix/*` → **merge** nach `main` **und** zurück nach `develop`.
- `release/*` → **merge** nach `main` **und** zurück nach `develop`.

### Regeln

- **MAJOR**: Inkompatible Änderungen (z. B. API-Bruch, grosse Architekturänderung).
- **MINOR**: Neue Features, die abwärtskompatibel sind.
- **PATCH**: Fehlerbehebungen oder kleine Anpassungen ohne Auswirkungen auf Schnittstellen.

### Zusammenhang mit Branching Strategie

- **release/** Branches tragen die neue geplante Version, z. B. `release/1.2.0`.
- Nach Abschluss wird ein **Tag** auf `main` gesetzt: `v1.2.0`.
- **hotfix/** Branches erzeugen neue **PATCH-Releases**, z. B. `v1.2.1`.

### Anwendungsbeispiele

- Erstes Release: `v1.0.0`  
  → Branch: `release/1.0.0`, Merge nach `main`.

- Neues Feature im Login-Modul: `v1.1.0`  
  → Entwicklung auf `feature/login`, Merge in `develop`, Release mit `release/1.1.0`.

- Kritischer Produktionsbug: `v1.1.1`  
  → Entwicklung auf `hotfix/789-db-connection`, Merge nach `main` und `develop`.
